# perfvec block_trace 本地适配流程说明（/root 环境，可复现）

本文记录把 `perfvec/block_trace/tracer/scripts/trace_wrapper.sh` 在当前服务器 `/root` 的文件环境中跑通所做的**修改**与**操作流程**，并包含关键改动的补丁内容，便于以后在相同/类似环境复现。

> 适配策略：**路线 B（改脚本为相对路径/可配置）**  
> gem5 μOP trace：**方案 4A（改 gem5 configs 接入 CLI 参数并启用 `MicroOpVerboseTracer`）**

---

## 1. 环境与约束

### 1.1 目录与项目

- `perfvec` 仓库：`/root/perfvec`
- gem5 修改版：`/root/gem5-ml-sim`
- tracer 入口：`/root/perfvec/block_trace/tracer/scripts/trace_wrapper.sh`

### 1.2 关键依赖（本机实测可用）

- LLVM：系统安装在 `/usr/lib/llvm-22`（包含 `clang/opt/llvm-objcopy/llvm-readelf/llvm-nm`，以及 `lib/cmake/llvm`）
- CMake：`cmake 3.22.1`
- SCons：`/usr/bin/scons`（v4.0.1）
- Conda 环境：`llmulator`（Python 3.10）

### 1.3 已知约束与处理方式

1) **`setarch -R` 禁用**  
容器/安全策略阻止关闭 ASLR：`setarch: ... Operation not permitted`。  
处理：`trace_wrapper.sh` 改为“探测 setarch 是否可用”，不可用则降级继续运行（不再失败退出）。

2) **gem5 构建时 Python 被 base conda 污染**  
base conda 的 `python3-config` 指向 Python 3.13，且 conda 侧缺少可被动态链接加载的 `libpython3.13.so.1.0`，会导致 gem5 构建阶段 `Checking Python version... no`。  
处理：构建 gem5 时固定：

```bash
export PYTHON_CONFIG=/usr/bin/python3-config
export PATH=/usr/bin:/bin:/usr/sbin:/sbin
```

3) **`llmulator` 环境无 `rg`**  
用 `grep` 替代。

4) **Conda 管理命令可能需要 `CONDA_OVERRIDE_CUDA=""`**  
由于当前执行环境 `/dev/shm` 不可写，conda 的 CUDA 虚拟包检测可能触发 `PermissionError`。  
如需 `conda info/env list` 等管理命令可使用：

```bash
CONDA_OVERRIDE_CUDA="" conda env list
```

---

## 2. 复现流程（从零到跑通 trace_wrapper）

下面命令假设你已经进入 `llmulator` 环境（`conda activate llmulator`），或使用 `conda run -n llmulator ...`。

### 2.1 构建 tracer（LLVM pass + runtime）

```bash
cd /root/perfvec/block_trace/tracer

# 建议显式指定系统 LLVM
export LLVM_HOME=/usr/lib/llvm-22

./scripts/build.sh
```

成功后应生成：

- `/root/perfvec/block_trace/tracer/build/passes/libBasicBlockTracer.so`
- `/root/perfvec/block_trace/tracer/build/runtime/libbbtrace_runtime.a`

### 2.2 构建 gem5（生成 gem5.fast）

建议在 `llmulator` 内构建，但必须强制使用系统 python3-config：

```bash
cd /root/gem5-ml-sim

export PYTHON_CONFIG=/usr/bin/python3-config
export PATH=/usr/bin:/bin:/usr/sbin:/sbin

/usr/bin/scons --ignore-style build/X86/gem5.fast -j1
```

> `-j1` 便于定位问题；稳定后可换 `-j8` / `-j$(nproc)`。

成功后产物：

- `/root/gem5-ml-sim/build/X86/gem5.fast`

### 2.3 验证 gem5 se.py 已支持 uop-trace 参数（方案 4A 生效）

```bash
/root/gem5-ml-sim/build/X86/gem5.fast \
  /root/gem5-ml-sim/configs/deprecated/example/se.py --help | grep -n "uop-trace"
```

期望看到：

- `--uop-trace-path`
- `--uop-trace-buffer`

### 2.4 运行 trace_wrapper（端到端）

```bash
cd /root/perfvec/block_trace/tracer

export LLVM_HOME=/usr/lib/llvm-22
export GEM5_ROOT=/root/gem5-ml-sim

./scripts/trace_wrapper.sh --src ./examples/matmul.c --name matmul_demo
```

输出目录示例：

- `/root/perfvec/block_trace/tracer/build/wrapper_runs/matmul_demo/<timestamp>/`

关键产物（示例）：

- `with_trace/trace_logs/bbtrace-*.jsonl`（LLVM 插桩动态 JSONL）
- `with_trace/bbtrace_ordered_trace.txt`（插桩 IR 对齐的可读文本）
- `with_trace/bbtrace_ordered_full.txt`（无插桩地址 + μOP 对齐文本）
- `without_trace/*.pcmap`、`without_trace/*.instmap`
- `gem5_runtime/without_trace/uop_trace/*.jsonl.pc_sorted`（μOP trace）
- `address_diff.json`

---

## 3. 变更清单与补丁（用于复现修改）

> 说明：下面列出本次适配所修改的文件及其 `git diff`（包含改动内容）。  
> perfvec 与 gem5-ml-sim 是两个仓库，补丁分别来自各自仓库的 `git diff`。

### 3.1 perfvec 仓库（/root/perfvec）

当前 `perfvec` HEAD（供记录）：`1a8f114015340808abea27ec1e0760c9acc20818`

#### 3.1.1 `block_trace/tracer/CMakeLists.txt`

```diff
diff --git a/block_trace/tracer/CMakeLists.txt b/block_trace/tracer/CMakeLists.txt
index 4f41ab8..5831f70 100644
--- a/block_trace/tracer/CMakeLists.txt
+++ b/block_trace/tracer/CMakeLists.txt
@@ -1,10 +1,21 @@
 cmake_minimum_required(VERSION 3.20)
-project(bbtracer LANGUAGES CXX)
+project(bbtracer LANGUAGES C CXX)
 
 set(CMAKE_CXX_STANDARD 17)
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
 
-set(LLVM_INSTALL_PREFIX "/home/chiplab/PRL/PerfVec/block_trace/llvm-install" CACHE PATH "LLVM install prefix")
+set(LLVM_INSTALL_PREFIX "" CACHE PATH "LLVM install prefix")
+if(LLVM_INSTALL_PREFIX STREQUAL "")
+  if(EXISTS "/usr/lib/llvm-22/lib/cmake/llvm/LLVMConfig.cmake")
+    set(LLVM_INSTALL_PREFIX "/usr/lib/llvm-22" CACHE PATH "LLVM install prefix" FORCE)
+  elseif(DEFINED ENV{LLVM_HOME} AND EXISTS "$ENV{LLVM_HOME}/lib/cmake/llvm/LLVMConfig.cmake")
+    set(LLVM_INSTALL_PREFIX "$ENV{LLVM_HOME}" CACHE PATH "LLVM install prefix" FORCE)
+  elseif(EXISTS "${CMAKE_SOURCE_DIR}/../llvm-install/lib/cmake/llvm/LLVMConfig.cmake")
+    set(LLVM_INSTALL_PREFIX "${CMAKE_SOURCE_DIR}/../llvm-install" CACHE PATH "LLVM install prefix" FORCE)
+  else()
+    message(FATAL_ERROR "LLVM not found. Set -DLLVM_INSTALL_PREFIX=... (expected <prefix>/lib/cmake/llvm/LLVMConfig.cmake).")
+  endif()
+endif()
 list(APPEND CMAKE_PREFIX_PATH "${LLVM_INSTALL_PREFIX}/lib/cmake/llvm")
 
 find_package(LLVM REQUIRED CONFIG)
@@ -12,9 +23,34 @@ message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION} at ${LLVM_INSTALL_PREFIX}")
 
 separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND "${LLVM_DEFINITIONS}")
 
-add_compile_definitions(${LLVM_DEFINITIONS_LIST})
+add_compile_options(${LLVM_DEFINITIONS_LIST})
 include_directories(${LLVM_INCLUDE_DIRS})
 
+if(NOT TARGET zstd::libzstd_shared)
+  find_library(BBTRACE_ZSTD_LIBRARY
+    NAMES zstd libzstd libzstd.so.1
+    PATHS /lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu
+  )
+  if(BBTRACE_ZSTD_LIBRARY)
+    add_library(zstd::libzstd_shared UNKNOWN IMPORTED)
+    set_target_properties(zstd::libzstd_shared PROPERTIES
+      IMPORTED_LOCATION "${BBTRACE_ZSTD_LIBRARY}"
+    )
+  endif()
+endif()
+
+if(NOT TARGET CURL::libcurl)
+  find_library(BBTRACE_CURL_LIBRARY
+    NAMES curl libcurl libcurl.so.4
+    PATHS /lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu
+  )
+  if(BBTRACE_CURL_LIBRARY)
+    add_library(CURL::libcurl UNKNOWN IMPORTED)
+    set_target_properties(CURL::libcurl PROPERTIES
+      IMPORTED_LOCATION "${BBTRACE_CURL_LIBRARY}"
+    )
+  endif()
+endif()
+
 add_subdirectory(runtime)
 add_subdirectory(passes)
```

#### 3.1.2 `block_trace/tracer/scripts/build.sh`

```diff
diff --git a/block_trace/tracer/scripts/build.sh b/block_trace/tracer/scripts/build.sh
index cbe7170..b8c1f2f 100755
--- a/block_trace/tracer/scripts/build.sh
+++ b/block_trace/tracer/scripts/build.sh
@@ -1,9 +1,32 @@
 #!/usr/bin/env bash
 set -euo pipefail
 
-PROJECT_ROOT="/home/chiplab/PRL/PerfVec/block_trace/tracer"
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
+BLOCK_TRACE_ROOT="$(cd "${PROJECT_ROOT}/.." && pwd)"
 BUILD_DIR="${PROJECT_ROOT}/build"
 
-cmake -S "${PROJECT_ROOT}" -B "${BUILD_DIR}"
-cmake --build "${BUILD_DIR}" -j"$(nproc)"
+LLVM_HOME="${LLVM_HOME:-}"
+if [[ -z "${LLVM_HOME}" ]]; then
+  if [[ -d "${BLOCK_TRACE_ROOT}/llvm-install" ]]; then
+    LLVM_HOME="${BLOCK_TRACE_ROOT}/llvm-install"
+  elif [[ -d "/usr/lib/llvm-22" ]]; then
+    LLVM_HOME="/usr/lib/llvm-22"
+  else
+    echo "[bbtrace] ERROR: LLVM 未找到；请设置 LLVM_HOME 或安装 LLVM (推荐 /usr/lib/llvm-22)" >&2
+    exit 1
+  fi
+fi
+
+CMAKE_ARGS=(
+  "-DLLVM_INSTALL_PREFIX=${LLVM_HOME}"
+)
+if [[ -x "${LLVM_HOME}/bin/clang" && -x "${LLVM_HOME}/bin/clang++" ]]; then
+  CMAKE_ARGS+=(
+    "-DCMAKE_C_COMPILER=${LLVM_HOME}/bin/clang"
+    "-DCMAKE_CXX_COMPILER=${LLVM_HOME}/bin/clang++"
+  )
+fi
+
+cmake -S "${PROJECT_ROOT}" -B "${BUILD_DIR}" "${CMAKE_ARGS[@]}"
+cmake --build "${BUILD_DIR}" -j"$(nproc)"
```

#### 3.1.3 `block_trace/tracer/scripts/run_example.sh`

```diff
diff --git a/block_trace/tracer/scripts/run_example.sh b/block_trace/tracer/scripts/run_example.sh
index 8220446..79f55f1 100755
--- a/block_trace/tracer/scripts/run_example.sh
+++ b/block_trace/tracer/scripts/run_example.sh
@@ -1,9 +1,23 @@
 #!/usr/bin/env bash
 set -euo pipefail
 
-PROJECT_ROOT="/home/chiplab/PRL/PerfVec/block_trace/tracer"
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
+BLOCK_TRACE_ROOT="$(cd "${PROJECT_ROOT}/.." && pwd)"
 BUILD_DIR="${PROJECT_ROOT}/build"
-LLVM_HOME="/home/chiplab/PRL/PerfVec/block_trace/llvm-install"
+
+LLVM_HOME="${LLVM_HOME:-}"
+if [[ -z "${LLVM_HOME}" ]]; then
+  if [[ -d "${BLOCK_TRACE_ROOT}/llvm-install" ]]; then
+    LLVM_HOME="${BLOCK_TRACE_ROOT}/llvm-install"
+  elif [[ -d "/usr/lib/llvm-22" ]]; then
+    LLVM_HOME="/usr/lib/llvm-22"
+  else
+    echo "[bbtrace] ERROR: LLVM 未找到；请设置 LLVM_HOME 或安装 LLVM (推荐 /usr/lib/llvm-22)" >&2
+    exit 1
+  fi
+fi
```

#### 3.1.4 `block_trace/tracer/scripts/trace_wrapper.sh`

```diff
diff --git a/block_trace/tracer/scripts/trace_wrapper.sh b/block_trace/tracer/scripts/trace_wrapper.sh
index 4f69e42..e6da92d 100755
--- a/block_trace/tracer/scripts/trace_wrapper.sh
+++ b/block_trace/tracer/scripts/trace_wrapper.sh
@@ -29,18 +29,69 @@ EOF
 }
 
 PROJECT_ROOT="/home/chiplab/PRL/PerfVec/block_trace/tracer"
-LLVM_HOME="/home/chiplab/PRL/PerfVec/block_trace/llvm-install"
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
+BLOCK_TRACE_ROOT="$(cd "${PROJECT_ROOT}/.." && pwd)"
+REPO_ROOT="$(cd "${BLOCK_TRACE_ROOT}/.." && pwd)"
+
+LLVM_HOME="${LLVM_HOME:-}"
+if [[ -z "${LLVM_HOME}" ]]; then
+  if [[ -d "${BLOCK_TRACE_ROOT}/llvm-install" ]]; then
+    LLVM_HOME="${BLOCK_TRACE_ROOT}/llvm-install"
+  elif [[ -d "/usr/lib/llvm-22" ]]; then
+    LLVM_HOME="/usr/lib/llvm-22"
+  else
+    echo "[trace-wrapper] ERROR: LLVM 未找到；请设置 LLVM_HOME 或安装 LLVM (推荐 /usr/lib/llvm-22)" >&2
+    exit 1
+  fi
+fi
+
 BUILD_DIR="${PROJECT_ROOT}/build"
 RUNTIME_LIB="${BUILD_DIR}/runtime/libbbtrace_runtime.a"
 PASS_LIB="${BUILD_DIR}/passes/libBasicBlockTracer.so"
-GEM5_ROOT="/home/chiplab/PRL/PerfVec/block_trace/gem5"
-GEM5_BIN="${GEM5_ROOT}/build/X86/gem5.fast"
-GEM5_CONFIG="${GEM5_ROOT}/configs/deprecated/example/se.py"
-GEM5_PYTHON_LIB="/home/chiplab/miniconda3/lib"
-if [[ -n "${LD_LIBRARY_PATH:-}" ]]; then
-  GEM5_DEFAULT_LD="${GEM5_PYTHON_LIB}:${LD_LIBRARY_PATH}"
+
+detect_gem5_root() {
+  if [[ -f "${BLOCK_TRACE_ROOT}/gem5/SConstruct" ]]; then
+    echo "${BLOCK_TRACE_ROOT}/gem5"
+    return 0
+  fi
+  if [[ -f "${REPO_ROOT}/gem5-ml-sim/SConstruct" ]]; then
+    echo "${REPO_ROOT}/gem5-ml-sim"
+    return 0
+  fi
+  if [[ -f "/root/gem5-ml-sim/SConstruct" ]]; then
+    echo "/root/gem5-ml-sim"
+    return 0
+  fi
+  return 1
+}
+
+GEM5_ROOT="${GEM5_ROOT:-$(detect_gem5_root || true)}"
+if [[ -z "${GEM5_ROOT}" ]]; then
+  echo "[trace-wrapper] ERROR: 未找到 gem5 目录；请设置 GEM5_ROOT 指向 gem5 源码目录（需要含 SConstruct）" >&2
+  exit 1
+fi
+
+GEM5_BIN="${GEM5_BIN:-${GEM5_ROOT}/build/X86/gem5.fast}"
+GEM5_CONFIG="${GEM5_CONFIG:-${GEM5_ROOT}/configs/deprecated/example/se.py}"
+
+GEM5_PYTHON_LIB="${GEM5_PYTHON_LIB:-}"
+if [[ -z "${GEM5_PYTHON_LIB}" ]]; then
+  if [[ -n "${CONDA_PREFIX:-}" && -d "${CONDA_PREFIX}/lib" ]]; then
+    GEM5_PYTHON_LIB="${CONDA_PREFIX}/lib"
+  else
+    GEM5_PYTHON_LIB="$(python3 -c 'import sysconfig; print(sysconfig.get_config_var("LIBDIR") or "")' 2>/dev/null || true)"
+  fi
+fi
+
+if [[ -n "${GEM5_PYTHON_LIB}" && -d "${GEM5_PYTHON_LIB}" ]]; then
+  if [[ -n "${LD_LIBRARY_PATH:-}" ]]; then
+    GEM5_DEFAULT_LD="${GEM5_PYTHON_LIB}:${LD_LIBRARY_PATH}"
+  else
+    GEM5_DEFAULT_LD="${GEM5_PYTHON_LIB}"
+  fi
 else
-  GEM5_DEFAULT_LD="${GEM5_PYTHON_LIB}"
+  GEM5_DEFAULT_LD="${LD_LIBRARY_PATH:-}"
 fi
@@
 if command -v setarch >/dev/null 2>&1; then
-  RUN_NO_ASLR=(setarch "$(uname -m)" -R)
+  if setarch "$(uname -m)" -R true >/dev/null 2>&1; then
+    RUN_NO_ASLR=(setarch "$(uname -m)" -R)
+  else
+    echo "[trace-wrapper] WARNING: setarch 存在但无法关闭 ASLR（可能被容器/安全策略禁用），将继续运行" >&2
+  fi
 else
   echo "[trace-wrapper] WARNING: setarch 未找到，运行阶段无法关闭 ASLR" >&2
 fi
```

#### 3.1.5 `block_trace/tracer/scripts/extract_pcmap.py`

```diff
diff --git a/block_trace/tracer/scripts/extract_pcmap.py b/block_trace/tracer/scripts/extract_pcmap.py
index 40d6621..b4a352e 100755
--- a/block_trace/tracer/scripts/extract_pcmap.py
+++ b/block_trace/tracer/scripts/extract_pcmap.py
@@ -5,6 +5,7 @@
 """
 import argparse
 import pathlib
+import shutil
 import struct
 import subprocess
 import sys
@@ -64,13 +65,17 @@ def main() -> None:
     parser.add_argument(
         "--llvm-objcopy",
         type=pathlib.Path,
-        default=pathlib.Path("/home/chiplab/PRL/PerfVec/block_trace/llvm-install/bin/llvm-objcopy"),
+        default=pathlib.Path(shutil.which("llvm-objcopy") or "llvm-objcopy"),
         help="llvm-objcopy 路径",
     )
     parser.add_argument(
         "--llvm-readelf",
         type=pathlib.Path,
-        default=pathlib.Path("/home/chiplab/PRL/PerfVec/block_trace/llvm-install/bin/llvm-readelf"),
+        default=pathlib.Path(
+            shutil.which("llvm-readelf")
+            or shutil.which("llvm-readelf-22")
+            or "llvm-readelf"
+        ),
         help="llvm-readelf 路径",
     )
```

#### 3.1.6 `block_trace/tracer/scripts/extract_inst_map.py`

```diff
diff --git a/block_trace/tracer/scripts/extract_inst_map.py b/block_trace/tracer/scripts/extract_inst_map.py
index fbc7f47..4dbce13 100644
--- a/block_trace/tracer/scripts/extract_inst_map.py
+++ b/block_trace/tracer/scripts/extract_inst_map.py
@@ -1,6 +1,7 @@
 #!/usr/bin/env python3
 import argparse
 import pathlib
+import shutil
 import struct
 import subprocess
 import sys
@@ -46,9 +47,7 @@ def main() -> None:
     parser.add_argument(
         "--llvm-objcopy",
         type=pathlib.Path,
-        default=pathlib.Path(
-            "/home/chiplab/PRL/PerfVec/block_trace/llvm-install/bin/llvm-objcopy"
-        ),
+        default=pathlib.Path(shutil.which("llvm-objcopy") or "llvm-objcopy"),
         help="path to llvm-objcopy",
     )
```

### 3.2 gem5-ml-sim 仓库（/root/gem5-ml-sim）

当前 `gem5-ml-sim` HEAD（供记录）：`8bd3ac47829c0d76788dffe13e2357d127db190e`

#### 3.2.1 `configs/common/Options.py`：增加 CLI 参数

```diff
diff --git a/configs/common/Options.py b/configs/common/Options.py
index 1e65262827..8c4aa2b6be 100644
--- a/configs/common/Options.py
+++ b/configs/common/Options.py
@@ -767,6 +767,18 @@ def addSEOptions(parser):
     parser.add_argument(
         "--wait-gdb",
         default=False,
         action="store_true",
         help="Wait for remote GDB to connect.",
     )
+
+    # Micro-op tracing (requires MicroOpVerboseTracer)
+    parser.add_argument(
+        "--uop-trace-path",
+        default="",
+        help="输出 μOP JSONL 路径（相对 m5out 或绝对路径）；空表示禁用",
+    )
+    parser.add_argument(
+        "--uop-trace-buffer",
+        default="8GB",
+        help="μOP trace 内存缓冲上限（例如 8GB, 512MB）",
+    )
```

#### 3.2.2 `configs/deprecated/example/se.py`：启用 MicroOpVerboseTracer（方案 4A）

```diff
diff --git a/configs/deprecated/example/se.py b/configs/deprecated/example/se.py
index 6ad4b02b32..e776695b93 100644
--- a/configs/deprecated/example/se.py
+++ b/configs/deprecated/example/se.py
@@ -264,6 +264,13 @@ for i in range(np):
 
     system.cpu[i].createThreads()
 
+if getattr(args, "uop_trace_path", ""):
+    tracer_kwargs = {"output_path": args.uop_trace_path}
+    if getattr(args, "uop_trace_buffer", ""):
+        tracer_kwargs["buffer_size"] = args.uop_trace_buffer
+    for cpu in system.cpu:
+        cpu.tracer = MicroOpVerboseTracer(**tracer_kwargs)
```

#### 3.2.3 `src/cpu/uop_tracer.hh` / `src/cpu/uop_tracer.cc`：修复计数器编译问题

```diff
diff --git a/src/cpu/uop_tracer.hh b/src/cpu/uop_tracer.hh
index eb4d60cdef..d519f194df 100644
--- a/src/cpu/uop_tracer.hh
+++ b/src/cpu/uop_tracer.hh
@@ -1,6 +1,7 @@
 #ifndef __CPU_UOP_TRACER_HH__
 #define __CPU_UOP_TRACER_HH__
 
+#include <atomic>
 #include <mutex>
 #include <string>
@@
     void append(const std::string &entry);
     void flush();
 
+    std::atomic<uint64_t> recordRequests{0};
+    std::atomic<uint64_t> recordsWritten{0};
+    std::atomic<uint64_t> droppedNoThread{0};
+    std::atomic<uint64_t> droppedNoInst{0};
+
diff --git a/src/cpu/uop_tracer.cc b/src/cpu/uop_tracer.cc
index b624ad8d49..629b3cdfbc 100644
--- a/src/cpu/uop_tracer.cc
+++ b/src/cpu/uop_tracer.cc
@@ -43,10 +43,10 @@ MicroOpVerboseTracer::MicroOpVerboseTracer(const Params &params)
 {
-    recordRequests = 0;
-    recordsWritten = 0;
-    droppedNoThread = 0;
-    droppedNoInst = 0;
+    recordRequests.store(0, std::memory_order_relaxed);
+    recordsWritten.store(0, std::memory_order_relaxed);
+    droppedNoThread.store(0, std::memory_order_relaxed);
+    droppedNoInst.store(0, std::memory_order_relaxed);
@@
-    recordRequests++;
+    recordRequests.fetch_add(1, std::memory_order_relaxed);
@@
-        droppedNoThread++;
+        droppedNoThread.fetch_add(1, std::memory_order_relaxed);
@@
-        droppedNoInst++;
+        droppedNoInst.fetch_add(1, std::memory_order_relaxed);
@@
-    recordsWritten++;
+    recordsWritten.fetch_add(1, std::memory_order_relaxed);
```

---

## 4. 常见问题（复现时）

### 4.1 `trace_wrapper.sh` 第 3/8 步执行失败：`setarch ... Operation not permitted`

原因：容器禁用 `setarch -R`。  
现状：脚本已改为自动降级继续跑，不影响最终产物。

### 4.2 gem5 构建：`Error: Can't find a working Python installation`

原因：命中了 base conda 的 `python3-config`（Python 3.13），产物链接到 `libpython3.13.so.1.0` 但系统找不到该 .so。  
解决：构建时强制：

```bash
export PYTHON_CONFIG=/usr/bin/python3-config
export PATH=/usr/bin:/bin:/usr/sbin:/sbin
```

并用 `/usr/bin/scons` 编译。

---

## 5. 关键产物的数据流（对齐关系图）

下面以一次 `trace_wrapper.sh` 的输出目录 `RUN_ROOT` 为基准，画出最终生成 `bbtrace_ordered_full.txt` 所依赖的关键文件（6~8 个）以及它们的对齐关系。

> 记号：`A -> B` 表示 “B 的生成/对齐需要用到 A”。

### 5.1 文件清单（最关键的 8 个）

1. `RUN_ROOT/gem5_runtime/with_trace/trace_logs/bbtrace-*.jsonl`  
   gem5 运行插桩二进制产生的动态事件流（JSONL）。

2. `RUN_ROOT/with_trace/bbtrace_static_export/*.bbinfo.jsonl`  
   LLVM pass 导出的静态 basic block 信息（bbinfo，包含 IR 文本/inst 静态信息/分支静态候选等）。

3. `RUN_ROOT/with_trace/matmul_demo_traced`  
   插桩二进制本体（用于导出 traced 的 pcmap；也用于宿主机/模拟器运行产生 JSONL）。

4. `RUN_ROOT/without_trace/matmul_demo_plain`  
   无插桩二进制本体（用于导出 plain 的 pcmap/instmap；也用于 gem5 生成 μOP trace）。

5. `RUN_ROOT/with_trace/matmul_demo_traced.pcmap`  
   从插桩二进制 `.bbtrace_map` 段导出的 `func_id/bb_id -> [start_pc,end_pc]`。

6. `RUN_ROOT/without_trace/matmul_demo_plain.pcmap`  
   从无插桩二进制 `.bbtrace_map` 段导出的 `func_id/bb_id -> [start_pc,end_pc]`（full 对齐时以它作为“最终地址体系”）。

7. `RUN_ROOT/without_trace/matmul_demo_plain.instmap`  
   从无插桩二进制 `.bbtrace_inst` 段导出的 `(func_id,bb_id,inst_id) -> pc`（把 IR 指令精确落到最终二进制 PC）。

8. `RUN_ROOT/gem5_runtime/without_trace/uop_trace/*_plain_uops.jsonl.pc_sorted`  
   gem5 `MicroOpVerboseTracer` 输出的 μOP JSONL（经 `sort_uop_trace.py` 排序），每行带 `pc/micro_pc/enter_tick/commit_tick/...`。

### 5.2 数据流与对齐逻辑（从 trace→bbinfo→pcmap/instmap→uop→ordered_full）

```text
               (1) gem5 traced 动态事件流
RUN_ROOT/gem5_runtime/with_trace/trace_logs/bbtrace-*.jsonl
                              |
                              | 解析 bb/call/load/store/branch 等事件
                              v
              +----------------------------------+
              | trace_to_text.py                 |
              | 负责把动态事件“翻译/注释”到静态 IR |
              +----------------------------------+
                              ^
                              | (2) 静态 bbinfo：func/bb -> IR/inst信息
RUN_ROOT/with_trace/bbtrace_static_export/*.bbinfo.jsonl
                              |
                              | （full 对齐还需要把“插桩视角”映射到“无插桩最终地址体系”）
                              v
            (6) plain pcmap: func/bb -> [start_pc,end_pc]  (最终地址体系)
RUN_ROOT/without_trace/matmul_demo_plain.pcmap
                              |
                              | (7) plain instmap: (func,b b,inst) -> pc (指令级对齐)
                              v
RUN_ROOT/without_trace/matmul_demo_plain.instmap
                              |
                              | (8) uop trace: pc/micro_pc -> enter_tick/commit_tick/...
                              v
RUN_ROOT/gem5_runtime/without_trace/uop_trace/*_plain_uops.jsonl.pc_sorted
                              |
                              v
RUN_ROOT/with_trace/bbtrace_ordered_full.txt
```

### 5.3 为什么要分 “traced trace” + “plain uop”

- 动态事件流（bb/call/load/store/branch 等）来自 LLVM 插桩，因此必须跑插桩版本；gem5 traced run 生成的是 (1)。
- μOP trace 来自 gem5 CPU tracer，理论上也能对插桩版本导出，但插桩会改变最终机器码布局/PC；为了把 μOP 时间轴对齐到“无插桩最终二进制”，wrapper 选择对无插桩版本跑 gem5 plain 并生成 (8)，再用 (6)(7) 做地址/指令级桥接，最终生成 `bbtrace_ordered_full.txt`。
